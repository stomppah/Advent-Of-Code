@page "/"

<PageTitle>Game of Life</PageTitle>

<h3>Conway's Game of Life</h3>

<div class="life-toolbar">
  <button class="btn btn-primary" @onclick="ToggleRun">@(running ? "‚è∏ Pause" : "‚ñ∂ Play")</button>
  <button class="btn btn-secondary" @onclick="Step" disabled="@running">‚è≠ Step</button>
  <button class="btn btn-secondary" @onclick="Randomize" disabled="@running">üé≤ Random</button>
  <button class="btn btn-secondary" @onclick="Clear" disabled="@running">üßπ Clear</button>

  <div class="spacer"></div>

  <label>Speed (ms):
    <input type="range" min="20" max="800" step="10" @bind="intervalMs" style="width: 140px;" />
    <span>@intervalMs</span>
  </label>

  <label style="margin-left:.75rem">Cols:
    <input type="number" min="10" max="200" @bind="cols" style="width:70px" />
  </label>
  <label>Rows:
    <input type="number" min="10" max="200" @bind="rows" style="width:70px" />
  </label>
  <button class="btn btn-outline-primary" @onclick="Resize" disabled="@running">Resize</button>
</div>

<div class="grid"
     style="@GridStyle"
     @onmousedown="StartDraw"
     @onmousemove="DuringDraw"
     @onmouseup="EndDraw"
     @onmouseleave="EndDraw">
  @for (int r = 0; r < rows; r++)
  {
    for (int c = 0; c < cols; c++)
    {
      var alive = grid[r, c];
      var previewing = isDrawing && drawValue.HasValue && hoverR == r && hoverC == c;
      <div class="cell @(alive ? "alive" : "") @(previewing ? "preview" : "")"
           @onclick="@(() => ToggleCell(r,c))"
           @onmousedown="@((_) => BeginDrawAt(r,c))"
           @onmousemove="@((_) => HoverAt(r,c))">
      </div>
    }
  }
</div>

<div class="life-stats">
  Generation: <b>@generation</b> |
  Alive: <b>@aliveCount</b>
</div>

@code {
  int rows = 40;
  int cols = 60;
  bool[,] grid = default!;
  bool[,] buffer = default!;
  int generation = 0;
  int aliveCount = 0;

  bool running = false;
  int intervalMs = 120;

  bool isDrawing = false;
  bool? drawValue = null;
  int hoverR = -1, hoverC = -1;

  System.Threading.CancellationTokenSource? loopCts;

  string GridStyle => $"grid-template-columns: repeat({cols}, 1fr); grid-template-rows: repeat({rows}, 1fr);";

  protected override void OnInitialized()
  {
    grid = new bool[rows, cols];
    buffer = new bool[rows, cols];
    CountAlive();
  }

  void ToggleRun()
  {
    running = !running;
    if (running)
    {
      loopCts?.Cancel();
      loopCts = new();
      _ = RunLoop(loopCts.Token);
    }
    else
    {
      loopCts?.Cancel();
    }
  }

  async Task RunLoop(CancellationToken ct)
  {
    try
    {
      while (!ct.IsCancellationRequested)
      {
        NextGeneration();
        await InvokeAsync(StateHasChanged);
        await Task.Delay(intervalMs, ct);
      }
    }
    catch (TaskCanceledException) { }
  }

  void Step()
  {
    if (running) return;
    NextGeneration();
  }

  void Randomize()
  {
    var rnd = new Random();
    for (int r = 0; r < rows; r++)
      for (int c = 0; c < cols; c++)
        grid[r, c] = rnd.NextDouble() < 0.25;
    generation = 0;
    CountAlive();
  }

  void Clear()
  {
    Array.Clear(grid, 0, grid.Length);
    generation = 0;
    CountAlive();
  }

  void Resize()
  {
    var newGrid = new bool[rows, cols];
    var newBuffer = new bool[rows, cols];
    int minR = Math.Min(rows, grid.GetLength(0));
    int minC = Math.Min(cols, grid.GetLength(1));
    for (int r = 0; r < minR; r++)
      for (int c = 0; c < minC; c++)
        newGrid[r, c] = grid[r, c];

    grid = newGrid;
    buffer = newBuffer;
    CountAlive();
  }

  void NextGeneration()
  {
    for (int r = 0; r < rows; r++)
    {
      for (int c = 0; c < cols; c++)
      {
        int n = CountNeighbors(r, c);
        bool alive = grid[r, c];
        bool next = alive ? (n == 2 || n == 3) : (n == 3);
        buffer[r, c] = next;
      }
    }
    (grid, buffer) = (buffer, grid);
    generation++;
    CountAlive();
  }

  int CountNeighbors(int r, int c)
  {
    int n = 0;
    for (int dr = -1; dr <= 1; dr++)
    {
      for (int dc = -1; dc <= 1; dc++)
      {
        if (dr == 0 && dc == 0) continue;
        int rr = r + dr;
        int cc = c + dc;
        if (rr >= 0 && rr < rows && cc >= 0 && cc < cols && grid[rr, cc])
          n++;
      }
    }
    return n;
  }

  void CountAlive()
  {
    int cnt = 0;
    foreach (var v in grid) if (v) cnt++;
    aliveCount = cnt;
  }

  void ToggleCell(int r, int c)
  {
    if (running) return;
    grid[r, c] = !grid[r, c];
    CountAlive();
  }

  void StartDraw(MouseEventArgs _) => isDrawing = true;

  void EndDraw(MouseEventArgs? _ = null)
  {
    isDrawing = false;
    drawValue = null;
    hoverR = hoverC = -1;
  }

  void DuringDraw(MouseEventArgs _) { }

  void BeginDrawAt(int r, int c)
  {
    if (running) return;
    isDrawing = true;
    drawValue = !grid[r, c];
    ApplyDraw(r, c);
  }

  void HoverAt(int r, int c)
  {
    hoverR = r; hoverC = c;
    if (isDrawing && drawValue.HasValue)
      ApplyDraw(r, c);
  }

  void ApplyDraw(int r, int c)
  {
    if (drawValue.HasValue)
    {
      if (grid[r, c] != drawValue.Value)
      {
        grid[r, c] = drawValue.Value;
        CountAlive();
      }
    }
  }

  public void Dispose()
  {
    loopCts?.Cancel();
    loopCts?.Dispose();
  }
}
